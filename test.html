<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
    </head>
    <body>
        <div>
        来自：[Ascii art generator in Java](http://korhner.github.io/java/image-processing/ascii-art-generator/)  \r\n[github源码地址](https://github.com/korhner/asciimg)  \r\n<!--more-->\r\n\r\nASCII码字符画艺术是一种利用ASCII码标准中的可打印字符来产生视觉艺术效果的技术，它的存在在历史上是有意义的，当时的打印机还无法打印图片，而且当时在邮件中嵌入图像还无法实现，所以它也用于邮件中。在本文中，我将为你呈现一个用Java实现的、可以配置字体和对比度的ASCII码字符画生成器程序。因为这个程序是我在周末用几个小时搞定的，还不完美，但这是一个有意思的实验，在下面你可以看到实现代码，我将解释它的工作原理。\r\n\r\n## 算法\r\n算法的思路很简单。首先，我们将程序中要用到的每一个字符转化成一张图片，并缓存它。然后，我们遍历原始图像，对于每个字符大小的图片块，找出最佳匹配的字符。为了实现这一点，我们首先对原始图像做一些预处理：我们先将图像转化为灰度图，然后让其通过一个阈值滤波器，这样我们就得到一个黑白色的图像，我们可以将其与每个字符对比并计算差值。接着，对每个图片块选取最相似的字符，一直进行下去，直到整个图像都转换完成。此外，我们还可以根据需要调整阈值大小来调整对比度，增强最终的效果。  \r\n为了实现这一点，一个非常简单的方法是将红、绿、蓝的值都设置成三种颜色的平均值：  \r\n红=绿=蓝=（红+绿+蓝）/3  \r\n如果这个值低于阈值，我们就将它设置成白色，否则我们将其设置成黑色。最后，我们以像素为单位将图像与每个字符进行比较并计算出平均误差。如下面的图片和代码片段所示。\r\n![eiffel](http://7xi5vu.com1.z0.glb.clouddn.com/2015-4-10Eiffel.png)\r\n\r\n```java\r\nint r1 = (charPixel >> 16) & 0xFF;\r\nint g1 = (charPixel >> 8) & 0xFF;\r\nint b1 = charPixel & 0xFF;\r\n\r\nint r2 = (sourcePixel >> 16) & 0xFF;\r\nint g2 = (sourcePixel >> 8) & 0xFF;\r\nint b2 = sourcePixel & 0xFF;\r\n\r\nint thresholded = (r2 + g2 + b2) / 3 < THRESHOLD ? 0 : 255;\r\n\r\nerror = Math.sqrt((r1 - thresholded) * (r1 - thresholded) + \r\n    (g1 - thresholded) * (g1 - thresholded) + (b1 - thresholded) * (b1 - thresholded));\r\n```\r\n\r\n因为颜色是存储在单个整数中，所以我们首先提取单个颜色成分并执行上面我解释过的计算，另一个挑战是准确地测量字符尺寸，并以它们为中心作图。在试验了多种方法之后，我最终发现这个比较好的方法：\r\n\r\n```\r\nRectangle rect = new TextLayout(Character.toString((char) i), fm.getFont(), \r\n    fm.getFontRenderContext()).getOutline(null).getBounds();\r\n\r\ng.drawString(character, 0, (int) (rect.getHeight() - rect.getMaxY()));\r\n```\r\n\r\n你可以在[Github](http://korhner.github.io/java/image-processing/ascii-art-generator/)上下载完整的源代码。  \r\n下面是一些使用不同字体尺寸和阈值的例子：\r\n![part1_9pic](http://7xi5vu.com1.z0.glb.clouddn.com/2015-4-10part1_9pic.png)\r\n\r\n--- \r\n\r\n## [Part 2](http://korhner.github.io/java/image-processing/ascii-art-generator-part-2/)\r\n由于[上一篇博客](http://korhner.github.io/java/image-processing/ascii-art-generator)谈到的ASCII码字符画生成器([在Github上查看源码](https://github.com/korhner/asciimg))收到了很多反馈,我决定继续这个项目，如果大家很喜欢的话我再增加几个feature。我重新设计了程序的主要部分，让它更具扩展性，易于采用不同的算法，生成不同的输出等等。在这一部分，我会展示这个项目的新的架构，让你可以更容易地集成到自己的代码中，按照你的需要扩展它。\r\n\r\n### 架构：\r\n\r\n![architecture](http://7xi5vu.com1.z0.glb.clouddn.com/2015-4-10architecture.png)\r\n\r\n### AsciiImgCache\r\n在渲染ASCII码字符之前，实例化这个类是必要的。它将字体和字符数组作为参数，为每个字母生成图片，如果你不想麻烦，代码中有默认的字符数组。  \r\n假如你好奇：\r\n\r\n```\r\nprivate static final char[] defaultCharacters = \r\n    \"$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\\\|()1{}[]?-_+~<>i!lI;:,\\\"^`'. \"\r\n```\r\n\r\n例子：\r\n\r\n```\r\n// use only '/' '\\' and ' '\r\nAsciiImgCache mediumBlackAndWhiteCache = AsciiImgCache.\r\n    create(new Font(\"Courier\", Font.BOLD, 10), new char[] {'\\\\', ' ', '/'});\r\n\r\n// use default list\r\nAsciiImgCache largeFontCache = AsciiImgCache.\r\n    create(new Font(\"Courier\",Font.PLAIN, 16));\r\n```\r\n---\r\n\r\n### BestCharacterFitStrategy\r\n这个类是用来确定原图片与每个字符有多接近的算法的抽象。它有一个方法：\r\n\r\n```\r\nfloat calculateError(final GrayscaleMatrix character, final GrayscaleMatrix tile);\r\n```\r\n\r\n这个方法比较两张图片，返回一个浮点型的误差。每个字母都将与图片比较，最小误差的那个将被选中，返回。目前这个类中有两个可用的方法：ColorSquareErrorFitStrategy和 StructuralSimilarityFitStrategy。\r\n\r\n#### ColorSquareErrorFitStrategy\r\n这个很容易理解，它比较每一个像素点，计算每个灰度的[均方差](http://zh.wikipedia.org/wiki/%E5%9D%87%E6%96%B9%E5%B7%AE)，用数学的语言来说就是：\r\n$MSE=\\frac{1}{n} \\sum\\limits_{1}\\limits^n(C_i-T_i)^2$\r\nn是像素点的个数，C和T分别是字符和分割的图片。\r\n\r\n#### StructuralSimilarityFitStrategy\r\n图像相似性指标（[The structural similarity (SSIM) index algorithm](http://baike.baidu.com/link?url=63n0Uy4dreTzmE2TzTYrk_tkgXvraZpK1H8EHqns-ogL61yOCTWwiCxp6VcoCoxPrAUlCvlusotYUEm0yR-KvK)）要求重现人类的感知，它的目标是提高类似与MSE的传统算法。我不会给出关于它机理的更多细节，如果你有兴趣，你可以在[Wikipedia](http://en.wikipedia.org/wiki/Structural_similarity)上面了解更多。我实验了一下，貌似实现了一个更优的版本。\r\n\r\n\r\n#### AsciiConverter  \r\n\r\n这是算法的核心，它包括了所有分割原图片、匹配最佳字符的逻辑的实现。但是，它不包含输出ASCII字符画--它需要子类的实现。目前有两种实现：AsciiToImageConverter 和 AsciiToStringConverter，你可能猜到了，图片是用字符串输出产生的。\r\n\r\n### 使用示例：\r\n既然talk is cheap，我就展示一下产生ASCII码图片的大致流程：\r\n\r\n```\r\n// initialize cache\r\nAsciiImgCache cache = AsciiImgCache.create(new Font(\"Courier\",Font.BOLD, 6));\r\n\r\n// load image\r\nBufferedImage portraitImage = ImageIO.read(new File(\"image.png\"));\r\n\r\n// initialize converters\r\nAsciiToImageConverter imageConverter = \r\n    new AsciiToImageConverter(cache, new ColorSquareErrorFitStrategy());\r\nAsciiToStringConverter stringConverter = \r\n    new AsciiToStringConverter(cache, new StructuralSimilarityFitStrategy());\r\n\r\n// image output\r\nImageIO.write(imageConverter.convertImage(portraitImage), \"png\", \r\n    new File(\"ascii_art.png\"));\r\n// string converter, output to console\r\nSystem.out.println(stringConverter.convertImage(portraitImage));\r\n```\r\n\r\n这有一些根据不同参数产生的实例图像：  \r\n**原始图像**\r\n![原始图像](http://7xi5vu.com1.z0.glb.clouddn.com/2015-4-10portrait.png)\r\n\r\n**16磅字体，MSE**\r\n![16磅字体，MSE](http://7xi5vu.com1.z0.glb.clouddn.com/2015-4-10portrait_large_square_error.png)\r\n\r\n**16磅字体，SSIM**\r\n![16磅字体，SSIM](http://7xi5vu.com1.z0.glb.clouddn.com/2015-4-10portrait_large_ssim.png)\r\n\r\n**3字符10磅字体，MSE**\r\n![3字符16磅字体，MSE](http://7xi5vu.com1.z0.glb.clouddn.com/2015-4-10portrait_medium_square_error.png)\r\n\r\n**3字符10磅字体，SSIM**\r\n![3字符16磅字体，SSIM](http://7xi5vu.com1.z0.glb.clouddn.com/2015-4-10portrait_medium_ssim.png)\r\n\r\n**6磅字体，MSE**\r\n![6磅字体，MSE](http://7xi5vu.com1.z0.glb.clouddn.com/2015-4-10portrait_small_square_error.png)\r\n\r\n**6磅字体，SSIM**\r\n![6磅字体，SSIM](http://7xi5vu.com1.z0.glb.clouddn.com/2015-4-10portrait_small_ssim.png)\r\n\r\n### 进一步的工作\r\n\r\n现在脑袋里有一些想法：\r\n * 搜索并尝试更多的图像比较的算法\r\n * 预处理图像，获得更好的结果（提高对比度，检测边缘等等）\r\n * 并行地进行图像处理，提高性能，尝试一下看看是否需要\r\n * 增加更多的转换结果（如html文件的输出）\r\n * 增加多种颜色字符的输出\r\n * 增加测试单元\r\n\r\n如果你想改善代码，或者发现了代码的bug，在博客里评论或者到[Github](https://github.com/korhner/asciimg)来贡献代码吧。",
        "pub_time" : ISODate("2016-05-02T09:10:59.213Z"),
        "update_time" : ISODate("2016-05-06T11:04:47.063Z"),
        "content_html" : "<p>来自：<a href=\"http://korhner.github.io/java/image-processing/ascii-art-generator/\">Ascii art generator in Java</a> <br />\n<a href=\"https://github.com/korhner/asciimg\">github源码地址</a> <br />\n<!--more--></p>\n\n<p>ASCII码字符画艺术是一种利用ASCII码标准中的可打印字符来产生视觉艺术效果的技术，它的存在在历史上是有意义的，当时的打印机还无法打印图片，而且当时在邮件中嵌入图像还无法实现，所以它也用于邮件中。在本文中，我将为你呈现一个用Java实现的、可以配置字体和对比度的ASCII码字符画生成器程序。因为这个程序是我在周末用几个小时搞定的，还不完美，但这是一个有意思的实验，在下面你可以看到实现代码，我将解释它的工作原理。</p>\n\n<h2>算法</h2>\n\n<p>算法的思路很简单。首先，我们将程序中要用到的每一个字符转化成一张图片，并缓存它。然后，我们遍历原始图像，对于每个字符大小的图片块，找出最佳匹配的字符。为了实现这一点，我们首先对原始图像做一些预处理：我们先将图像转化为灰度图，然后让其通过一个阈值滤波器，这样我们就得到一个黑白色的图像，我们可以将其与每个字符对比并计算差值。接着，对每个图片块选取最相似的字符，一直进行下去，直到整个图像都转换完成。此外，我们还可以根据需要调整阈值大小来调整对比度，增强最终的效果。 <br />\n为了实现这一点，一个非常简单的方法是将红、绿、蓝的值都设置成三种颜色的平均值： <br />\n红=绿=蓝=（红+绿+蓝）/3 <br />\n如果这个值低于阈值，我们就将它设置成白色，否则我们将其设置成黑色。最后，我们以像素为单位将图像与每个字符进行比较并计算出平均误差。如下面的图片和代码片段所示。\n<img src=\"http://7xi5vu.com1.z0.glb.clouddn.com/2015-4-10Eiffel.png\" alt=\"eiffel\" /></p>\n\n<pre><code>int r1 = (charPixel &gt;&gt; 16) &amp; 0xFF;\nint g1 = (charPixel &gt;&gt; 8) &amp; 0xFF;\nint b1 = charPixel &amp; 0xFF;\n\nint r2 = (sourcePixel &gt;&gt; 16) &amp; 0xFF;\nint g2 = (sourcePixel &gt;&gt; 8) &amp; 0xFF;\nint b2 = sourcePixel &amp; 0xFF;\n\nint thresholded = (r2 + g2 + b2) / 3 &lt; THRESHOLD ? 0 : 255;\n\nerror = Math.sqrt((r1 - thresholded) * (r1 - thresholded) + \n    (g1 - thresholded) * (g1 - thresholded) + (b1 - thresholded) * (b1 - thresholded));\n</code></pre>\n\n<p>因为颜色是存储在单个整数中，所以我们首先提取单个颜色成分并执行上面我解释过的计算，另一个挑战是准确地测量字符尺寸，并以它们为中心作图。在试验了多种方法之后，我最终发现这个比较好的方法：</p>\n\n<pre><code>Rectangle rect = new TextLayout(Character.toString((char) i), fm.getFont(), \n    fm.getFontRenderContext()).getOutline(null).getBounds();\n\ng.drawString(character, 0, (int) (rect.getHeight() - rect.getMaxY()));\n</code></pre>\n\n<p>你可以在<a href=\"http://korhner.github.io/java/image-processing/ascii-art-generator/\">Github</a>上下载完整的源代码。 <br />\n下面是一些使用不同字体尺寸和阈值的例子：\n<img src=\"http://7xi5vu.com1.z0.glb.clouddn.com/2015-4-10part1_9pic.png\" alt=\"part1_9pic\" /></p>\n\n<hr />\n\n<h2><a href=\"http://korhner.github.io/java/image-processing/ascii-art-generator-part-2/\">Part 2</a></h2>\n\n<p>由于<a href=\"http://korhner.github.io/java/image-processing/ascii-art-generator\">上一篇博客</a>谈到的ASCII码字符画生成器(<a href=\"https://github.com/korhner/asciimg\">在Github上查看源码</a>)收到了很多反馈,我决定继续这个项目，如果大家很喜欢的话我再增加几个feature。我重新设计了程序的主要部分，让它更具扩展性，易于采用不同的算法，生成不同的输出等等。在这一部分，我会展示这个项目的新的架构，让你可以更容易地集成到自己的代码中，按照你的需要扩展它。</p>\n\n<h3>架构：</h3>\n\n<p><img src=\"http://7xi5vu.com1.z0.glb.clouddn.com/2015-4-10architecture.png\" alt=\"architecture\" /></p>\n\n<h3>AsciiImgCache</h3>\n\n<p>在渲染ASCII码字符之前，实例化这个类是必要的。它将字体和字符数组作为参数，为每个字母生成图片，如果你不想麻烦，代码中有默认的字符数组。 <br />\n假如你好奇：</p>\n\n<pre><code>private static final char[] defaultCharacters = \n    \"$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\\\|()1{}[]?-_+~&lt;&gt;i!lI;:,\\\"^`'. \"\n</code></pre>\n\n<p>例子：</p>\n\n<pre><code>// use only '/' '\\' and ' '\nAsciiImgCache mediumBlackAndWhiteCache = AsciiImgCache.\n    create(new Font(\"Courier\", Font.BOLD, 10), new char[] {'\\\\', ' ', '/'});\n\n// use default list\nAsciiImgCache largeFontCache = AsciiImgCache.\n    create(new Font(\"Courier\",Font.PLAIN, 16));\n</code></pre>\n\n<hr />\n\n<h3>BestCharacterFitStrategy</h3>\n\n<p>这个类是用来确定原图片与每个字符有多接近的算法的抽象。它有一个方法：</p>\n\n<pre><code>float calculateError(final GrayscaleMatrix character, final GrayscaleMatrix tile);\n</code></pre>\n\n<p>这个方法比较两张图片，返回一个浮点型的误差。每个字母都将与图片比较，最小误差的那个将被选中，返回。目前这个类中有两个可用的方法：ColorSquareErrorFitStrategy和 StructuralSimilarityFitStrategy。</p>\n\n<h4>ColorSquareErrorFitStrategy</h4>\n\n<p>这个很容易理解，它比较每一个像素点，计算每个灰度的<a href=\"http://zh.wikipedia.org/wiki/%E5%9D%87%E6%96%B9%E5%B7%AE\">均方差</a>，用数学的语言来说就是：\n$MSE=\\frac{1}{n} \\sum\\limits_{1}\\limits^n(C_i-T_i)^2$\nn是像素点的个数，C和T分别是字符和分割的图片。</p>\n\n<h4>StructuralSimilarityFitStrategy</h4>\n\n<p>图像相似性指标（<a href=\"http://baike.baidu.com/link?url=63n0Uy4dreTzmE2TzTYrk_tkgXvraZpK1H8EHqns-ogL61yOCTWwiCxp6VcoCoxPrAUlCvlusotYUEm0yR-KvK\">The structural similarity (SSIM) index algorithm</a>）要求重现人类的感知，它的目标是提高类似与MSE的传统算法。我不会给出关于它机理的更多细节，如果你有兴趣，你可以在<a href=\"http://en.wikipedia.org/wiki/Structural_similarity\">Wikipedia</a>上面了解更多。我实验了一下，貌似实现了一个更优的版本。</p>\n\n<h4>AsciiConverter</h4>\n\n<p>这是算法的核心，它包括了所有分割原图片、匹配最佳字符的逻辑的实现。但是，它不包含输出ASCII字符画--它需要子类的实现。目前有两种实现：AsciiToImageConverter 和 AsciiToStringConverter，你可能猜到了，图片是用字符串输出产生的。</p>\n\n<h3>使用示例：</h3>\n\n<p>既然talk is cheap，我就展示一下产生ASCII码图片的大致流程：</p>\n\n<pre><code>// initialize cache\nAsciiImgCache cache = AsciiImgCache.create(new Font(\"Courier\",Font.BOLD, 6));\n\n// load image\nBufferedImage portraitImage = ImageIO.read(new File(\"image.png\"));\n\n// initialize converters\nAsciiToImageConverter imageConverter = \n    new AsciiToImageConverter(cache, new ColorSquareErrorFitStrategy());\nAsciiToStringConverter stringConverter = \n    new AsciiToStringConverter(cache, new StructuralSimilarityFitStrategy());\n\n// image output\nImageIO.write(imageConverter.convertImage(portraitImage), \"png\", \n    new File(\"ascii_art.png\"));\n// string converter, output to console\nSystem.out.println(stringConverter.convertImage(portraitImage));\n</code></pre>\n\n<p>这有一些根据不同参数产生的实例图像： <br />\n<strong>原始图像</strong>\n<img src=\"http://7xi5vu.com1.z0.glb.clouddn.com/2015-4-10portrait.png\" alt=\"原始图像\" /></p>\n\n<p><strong>16磅字体，MSE</strong>\n<img src=\"http://7xi5vu.com1.z0.glb.clouddn.com/2015-4-10portrait_large_square_error.png\" alt=\"16磅字体，MSE\" /></p>\n\n<p><strong>16磅字体，SSIM</strong>\n<img src=\"http://7xi5vu.com1.z0.glb.clouddn.com/2015-4-10portrait_large_ssim.png\" alt=\"16磅字体，SSIM\" /></p>\n\n<p><strong>3字符10磅字体，MSE</strong>\n<img src=\"http://7xi5vu.com1.z0.glb.clouddn.com/2015-4-10portrait_medium_square_error.png\" alt=\"3字符16磅字体，MSE\" /></p>\n\n<p><strong>3字符10磅字体，SSIM</strong>\n<img src=\"http://7xi5vu.com1.z0.glb.clouddn.com/2015-4-10portrait_medium_ssim.png\" alt=\"3字符16磅字体，SSIM\" /></p>\n\n<p><strong>6磅字体，MSE</strong>\n<img src=\"http://7xi5vu.com1.z0.glb.clouddn.com/2015-4-10portrait_small_square_error.png\" alt=\"6磅字体，MSE\" /></p>\n\n<p><strong>6磅字体，SSIM</strong>\n<img src=\"http://7xi5vu.com1.z0.glb.clouddn.com/2015-4-10portrait_small_ssim.png\" alt=\"6磅字体，SSIM\" /></p>\n\n<h3>进一步的工作</h3>\n\n<p>现在脑袋里有一些想法：\n * 搜索并尝试更多的图像比较的算法\n * 预处理图像，获得更好的结果（提高对比度，检测边缘等等）\n * 并行地进行图像处理，提高性能，尝试一下看看是否需要\n * 增加更多的转换结果（如html文件的输出）\n * 增加多种颜色字符的输出\n * 增加测试单元</p>\n\n<p>如果你想改善代码，或者发现了代码的bug，在博客里评论或者到<a href=\"https://github.com/korhner/asciimg\">Github</a>来贡献代码吧。</p>\n
        </div>
    </body>
</html>
